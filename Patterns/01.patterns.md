# Patterns

- [Patterns](#patterns)
	- [Sources](#sources)
	- [Theory](#theory)
		- [Intro](#intro)
		- [Pattern categorization](#pattern-categorization)
	- [Creational Patterns](#creational-patterns)
		- [Constructor](#constructor)
		- [Factory](#factory)
		- [Prototype](#prototype)
		- [Singleton](#singleton)
	- [Structural](#structural)

***


## Sources

1. https://addyosmani.com/resources/essentialjsdesignpatterns/book/#designpatternsjavascript - JavsScript Design Patterns (to work it through better in the future)
2. https://youtu.be/YJVj4XNASDk - minin

***


## Theory

### Intro

Patterns are reusable solutions that can be applied to commonly occurring problems. This contributes to the scalability and clarity of your project.

Why using them?

1. Patterns are proven solid solutions for solving common issues. They are thoroughly tested. 
2. Patterns can be easily reused. They provide out of the box solutions that can be easily adapted. 
3. Patterns can be expressive - we can understand what they are doing at first sight.

Patterns **are not** exact solutions, though. They only provide a solution scheme and **need to be adapted** for your specific **context**. 

***

### Pattern [categorization](https://addyosmani.com/resources/essentialjsdesignpatterns/book/#categoriesofdesignpatterns)

Patterns can be:

- **Creational** based on the concept of creating an object.
- **Structural** based on the idea of building blocks of objects. They allow us to add new features into existing code without breaking it.
- **Behavioral** based on the way objects play and work together.

***


## Creational Patterns

### Constructor

The most common pattern: we create a **constructor functioin** or a **class** to produce specific objects for us. 

```js
/* ES5 */
// function Person(name, surname) {
// 	this.name = name
// 	this.surname = surname
// }

// Person.prototype.getFullname = function () {
// 	return this.name + ' ' + this.surname
// }

/* ES6 */
class Person {
	constructor(name, surname) {
		this.name = name
		this.surname = surname
	}

	getFullname() {
		return this.name + ' ' + this.surname
	}
}

const person = new Person('Max', 'Bar')
console.log(person)
console.log(person.getFullname())
```

***

### Factory

Factory pattern allows us to produce instances of **different classes** using the universal interface (usually something like `create()` method). The instance class is decided from the passed parameters. 

Use cases:

- the component setup is complex
- our objects depend on the environment
- our components share the same properties
- we need "duck typing" in our objects to satisfy an API

```js
class SimpleMembership {
	constructor(name) {
		this.name = name
		this.cost = 50
	}
}

class StandardMembership {
	constructor(name) {
		this.name = name
		this.cost = 150
	}
}

class PremiumMembership {
	constructor(name) {
		this.name = name
		this.cost = 500
	}
}

class MemberFactory {
	static list = {
		simple: SimpleMembership,
		standard: StandardMembership,
		premium: PremiumMembership
	}

	create(name, type = 'simple') {
		const Membership = MemberFactory.list[type] || MemberFactory.list.simple
		const member = new Membership(name)

		// We created an instance of the needed class and are ready to return it.
		// But here we can extend it with additional properties and methods - that's an advantage of the factory pattern.
		member.type = type
		member.define = function () {
			console.log(`${this.name} (${this.type}): ${this.cost}`)
		}

		return member
	}
}

const factory = new MemberFactory()

const members = [
	factory.create('Boris', 'premium'), 
	factory.create('Inna', 'standard'), 
	factory.create('Oleg')
]

members.forEach((member) => member.define())
/* Boris (premium): 500
Inna (standard): 50
Oleg (simple): 50 */
```

Even more complex Abstract Factories can include several factories as methods for even greater abstraction.

***

### Prototype

We can use some objects as templates for other objects using the prototype inheritance. 

Prototypes store properties and especially methods that are **common** for all objects in this prototype chain, so **they don't have** to be present in each and every instance. 

```js
const car = {
	wheels: 4,

	init() {
		console.log(`I have ${this.wheels} wheels and my owner is ${this.owner}`)
	}
}

const carWithOwner = Object.create(car, {
	owner: {
		value: 'Khan'
	}
})

// Our object takes properties and methods from its prototype
carWithOwner.init()
// Our object DOES inherit from `car`
console.log(Object.getPrototypeOf(carWithOwner) === car)
```

***

### Singleton

Restricts a class to **a single** instance which is accessible to clients from a well-known access point. 

```js
class Database {
	constructor(data) {
		if (Database.exists) {
			return Database.instance
		}

		Database.instance = this
		Database.exists = true
		this.data = data
	}

	getData() {
		return this.data
	}
}

const mongo = new Database('MongoDB')
console.log(mongo.getData())

const mysql = new Database('MySQL')
console.log(mysql === mongo)	// true
```

***


## Structural

