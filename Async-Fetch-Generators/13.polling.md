# Client-Server Interaction

- [Client-Server Interaction](#client-server-interaction)
  - [Sources](#sources)
  - [Regular Polling](#regular-polling)
  - [Long polling](#long-polling)
  - [EventSource](#eventsource)

---

## Sources

1. https://javascript.info/long-polling
2.

---

If the client doesn't use some special ways of communicating with the server (e.g. websocket), then he usually uses a standard **request-response** model. But they can be different.

## Regular Polling

The simplest way to get new information from the server. Basically regular requests to the server: "Do you have anything for me?" Now server knows that the client is online, and can send a response with any accumulated info up to this time.

Pros:

- easy to implement

Cons:

- Messages are passed with a delay (between requests).
- Server needs to repeatedly answer to a huge amount of requests (from all users!), even if there's nothing to respond with.

---

## Long polling

A better way to poll the server in many situations.

Pros:

- works good if messages are rare

Cons:

- works not very good if messages are frequent (as every request-response is supplied with headers and other metadata making them "heavy")

Algorithm:

1. A **client sends request** to the server.
2. The **server doesn't respond** immediately but **waits** for something to respond with.
3. When there are something to send to the client, the server finally **responds**.
4. The **client gets the response** and sends the **new request immediately**.

The situation when the browser sent a request and has a pending connection with the server, is standard for this method. Only when a message is delivered, the connection is reestablished.

![](img/2020-10-08-00-47-40.png)

If the **connection is lost**, because of, say, a network error, the browser **immediately** sends a new request.

```js
async function run(){
	const response = fetch('...')
	if(response.status ...){}

	await run()
}
```

**NB**: this code doesn't run into _recursion_ because this is basically a chain of `Promises`, one handler is executed when the previous is finished.

---

## EventSource
