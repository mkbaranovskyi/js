# WebSocket Client

- [WebSocket Client](#websocket-client)
	- [Intro](#intro)
		- [Events](#events)
		- [Methods](#methods)
		- [Connection state](#connection-state)
	- [Client-server conversation](#client-server-conversation)
	- [Data transfer](#data-transfer)
	- [Practice](#practice)
		- [Basic example](#basic-example)
		- [Chat example](#chat-example)
- [WebSocket Server](#websocket-server)
	- [Class: WebSocket.Server](#class-websocketserver)
		- [`new `**`WebSocket.Server`**` (options[, callback])`](#new-websocketserver-options-callback)
		- [Events](#events-1)
			- [`wss.on (`**`'close'`**`, () => {})`](#wsson-close---)
			- [`wss.on (`**`'connection'`**`, (socket: WebSocket, request: http.IncomingMessage) => {})`](#wsson-connection-socket-websocket-request-httpincomingmessage--)
			- [`wss.on (`**`'error'`**`, (err: Error) => {})`](#wsson-error-err-error--)
			- [`wss.on (`**`'headers'`**`, (headers: Array, request: http.IncomingMessage))`](#wsson-headers-headers-array-request-httpincomingmessage)
			- [`wss.on (`**`'listening'`**`, () => {})`](#wsson-listening---)


***

## Intro

WebSocket protocol provides a way to exchange data between browser and server via a persistent connection. The data can be passed in both directions as “packets”, without breaking the connection and additional HTTP-requests.

```js
const socket = new WebSocket("wss://javascript.info")
```

There can be additional headers sent to the server, indicationg that the client want to use specific format, compression, etc. 

```js
const socket = new WebSocket("wss://javascript.info/chat", ["soap", "wamp"])
```

***


### Events

Once the socket is created, we should **listen** for events on it:

1. `open` - connection established
2. `message` - data received
3. `error` - error
4. `close` - connection closed

***


### Methods

1. `socket.send(data)` to send data. 
2. `socket.close( [{params}] )` to close the connection. Optional params include `code` and `reason` explaining why the connection was closed. 

***


### Connection state

Defined by `socket.readyState`

- `0` - “CONNECTING”: the connection has not yet been established
- `1` - “OPEN”: communicating
- `2` - “CLOSING”: the connection is closing
- `3` - “CLOSED”: the connection is closed

***



## Client-server conversation

During the connection the browser (using headers) asks the server: “Do you support Websocket?” And if the server replies “yes”, then the talk continues in WebSocket protocol.

Headers:

```http
GET /chat
Host: javascript.info
Origin: https://javascript.info
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q==
Sec-WebSocket-Version: 13
```

`Origin` - origin of the page. WebSocket is cross-origin by nature so no extra headers needed.

`Connection: Upgrade` - signals that the client would like to change the protocol.

`Upgrade: websocket` – the requested protocol is “websocket”.

`Sec-WebSocket-Key` – a random browser-generated key for security.

***

If the server agrees to switch to WebSocket, it should send code `101 (Switching protocol)` response:

```http
101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=
```

Afterwards, the data is transfered using WebSocket protocol and **not HTTP**.

***



## Data transfer

WebSocket communication consists of **“frames”** – data fragments, that can be sent from either side, and can be of several kinds:

- text
- binary data (set by `socket.binaryType`, it's `Blob` by default)
- ping/pong frames (used to check the connection, sent from server)
- "connection close frame" and a few others technical ones

***



## Practice 

### Basic example

```js
const socket = new WebSocket('wss://javascript.info/article/websocket/demo/hello')

socket.onopen = e => {
	console.log('Connection open')
	console.log(e)
	socket.send('My name is Max')
}

socket.onmessage = e => {
	console.log(`Data received from server`)
	console.log(e)
}

socket.onclose = e => {
	console.log('Connection closed')
	console.log(e)
}

socket.error = e => {
	console.log('Error')
	console.log(e)
}
```

![](img/2020-09-22-10-56-31.png)

![](img/2020-09-22-11-08-07.png)

![](img/2020-09-22-11-09-26.png)

***

You might wish to check the `bufferAmount` property of the **socket** before closing the connection as it indicates how much data was sent and still going over the network (0 means no more data is expected to come).

![](img/2020-09-22-12-13-58.png)

***


### Chat example

This simple ws-server echoes sent messages.

We'll need a **form** to send messages and a **div** to display incoming messages.

Algorithms:

1. Open the connection.
2. On form submission - `socket.send(message)`.
3. On incoming messages - append them to our **div**.

```html
<form name="publish">
	<label for="msg">Enter your message: </label>
	<input type="text" name="msg" id="msg"><br>
	<button type="submit" id="sub">Submit</button>
</form>

<div id="messages"></div>

<script>
	const socket = new WebSocket('wss://javascript.info/article/websocket/chat/ws')

	document.forms.publish.onsubmit = e => {
		if(socket.readyState === 1){	// connection is open
			socket.send(msg.value)
		}
		return false
	}

	socket.onmessage = e => {
		console.log(e.data)
		const div = document.createElement('div')
		document.getElementById('messages').prepend(div)
		div.textContent = e.data
	}
</script>
```
***



# WebSocket Server

1. https://www.npmjs.com/package/ws
2. https://github.com/websockets/ws/blob/HEAD/doc/ws.md

```bash
npm i ws
```

Basic structure - **Server**:

```js
const express = require('express')
const app = express()
const path = require('path')
const WebSocket = require('ws')

const PORT = process.env.PORT || 5000
const wss = new WebSocket.Server({ port: 5001 })

app.use(express.static(path.join(__dirname, 'public')))

wss.on('connection', function connection(ws) {
	console.log('A new client connected')

	ws.on('message', function incoming(message) {
		console.log('received: ', message)
		// echo the client message back to him
		ws.send(message)
	})
})

app.listen(PORT, () => {
	console.log(`The app is running on port ${PORT}`)
})
```

**Client**:

```html
<form name="publish">
	<label for="msg">Enter your message: </label>
	<input type="text" name="msg" id="msg"><br>
	<button type="submit" id="sub">Submit</button>
</form>

<div id="messages"></div>

<script>
	const socket = new WebSocket('ws://localhost:5001')

	document.forms.publish.onsubmit = e => {
		socket.send(msg.value)			
		return false
	}

	socket.onmessage = e => {
		console.log(e.data)
		const div = document.createElement('div')
		document.getElementById('messages').prepend(div)
		div.textContent = e.data
	}
</script>
```

***



## Class: WebSocket.Server

### `new `**`WebSocket.Server`**` (options[, callback])`

![](img/2020-10-06-00-14-56.png)

Create a new server instance. One of `port`, `server` or `noServer` must be provided. If `port` is chosen, an http server is created automatically. 

The `"noServer"` mode allows the WebSocket server to be completly detached from the HTTP/S server. This makes it possible, for example, to share a single HTTP/S server between multiple WebSocket servers.

Examples:

```js
const WebSocket = require('ws')
const wss = new WebSocket.Server({ port: 5001 })
// the port should be different from the one used for `http` connection
```

```js
const express = require('express')
const app = express()
const server = require('http').createServer(app)

const WebSocket = require('ws')
// either
const wss = new WebSocket.Server({ server })
// or simply
const wss = new WebSocket.Server({ app })
```

***


### Events

#### `wss.on (`**`'close'`**`, () => {})`

Emitted when the server closes.

***


#### `wss.on (`**`'connection'`**`, (socket: WebSocket, request: http.IncomingMessage) => {})`

Emitted when the handshake is complete. `request` is the http GET request sent by the client. Useful for parsing authority headers, cookie headers, and other information.

***


#### `wss.on (`**`'error'`**`, (err: Error) => {})`

Emitted when an error occurs on the underlying server.

***


#### `wss.on (`**`'headers'`**`, (headers: Array, request: http.IncomingMessage))`

Emitted before the response headers are written to the socket as part of the handshake. This allows you to inspect/modify the headers before they are sent.

***


#### `wss.on (`**`'listening'`**`, () => {})`

Emitted when the underlying server has been bound.

***




