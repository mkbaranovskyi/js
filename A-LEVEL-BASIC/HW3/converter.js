'use strict'

let temp,           // температура
    from,           // величина ИЗ
    to,             // величина В
    result,         // результат преобразования
    history = []    // история 

// Управляющий цикл для прокрутки всех действий
while (confirm("Хотите перевести температуру из одной единицы измерения в другую?")) { // если Отмена, то null, а до тех пор вечный цикл
    if(askData() === null){                                         // вызываем функцию и сразу проверяем результат вызова
        alert("Ошибка! Пожалуйста, введите сначала число, а потом один из вариантов ответа в скобках (один латинский символ в верхнем регистре).")
        continue                                                    // прыг на следующую итерацию
    }

    result = converter(temp, from, to)
    history[history.length] = `${temp} \u00B0${from} = ${result}`   // дописать в конец массива
    alert(history[history.length - 1])                              // показать последнюю запись
}

// Если массив не пуст, то вывести историю
if(history.length > 0){                                             
    alert("История ваших преобразований доступна в консоли!")
    console.log(history)
}


// Вспомогательная функция для наполнения глобальных переменных данными пользователя
function askData() {
    temp = +prompt("Введите температуру:", 0)   // плюсик для приведения к числовому типу
    if (typeof temp === 'number') {             // если нормально преобразуется к числу, то следующий вопрос
        from = prompt("Что переводим? (C/F/K)", 'C')
        if (from === 'C' || from === 'F' || from === 'K') { // если все ок, то следующий вопрос
            to = prompt("Во что переводим? (C/F/K)", 'F')
            if (to === 'C' || to === 'F' || to === 'K') {   // если все ок, то выходим, мы тут закончили
                return                                      // безболезненный return undefined, результаты мы непосредственно записали в глобальные переменные
            } 
        }
    } 

    return null // интерпретатор дойдет сюда только если не выйдет из функции раньше, то есть если на любом этапе выше будет false
}

// Конвертер, входные параметры: температура (число), из какой величины (корректная строка), в какую величину (корректная строка)
function converter(temp, from, to){
    let result

    if(from === 'C'){
        if(to === 'F'){
            result = temp * 9 / 5 + 32
        } 
        else {
            if(to === 'K'){
                result = temp + 273.15
            } 
        }
    } 
    
    else {
        if(from === 'F'){
            if(to === 'C'){
                result = (temp - 32) * 5 / 9
            } 
            else {
                if(to === 'K'){
                    result = (temp - 32) * 5 / 9 + 273.15
                } 
            }
        }

        else {
            if(from === 'K'){
                if(to === 'C'){
                    result = temp - 273.15
                } 
                else {
                    if(to === 'F'){
                        result = (temp - 273.15) * 9 / 5 + 32
                    } 
                }
            }
        }
    }

    // Если ни один из if не выстрелил, то result останется undefined. Таким образом мы реализуем принцип DRY (don't repeat yourself - не повторяйся!)
    if(result === undefined){
        return null
    }

    result = Math.round(result * 10) / 10   // округляем до 1 знака после запятой (не идеальное решение, возможна потеря точности)
    result += " \u00B0" + to                // добавляем через пробел символ градуса в кодировке юникода и величину, к которой привели

    return result
}


/* Обрати внимание, что в функции нет никакого мусора - алертов, консоль логов, промптов и т.д. Это значит, что ее можно будет безболезненно вызвать в любом другом коде, ничего не изменяя внутри, и удобно работать с тем, что она возвращает (null или строка, которую можно легко распарсить и извлечь данные благодаря пробелу между числом и обозначением градусов - для этого есть спец функции) */

